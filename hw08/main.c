#include "main.h"
// Kevin Lin
// Summer 2022
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Images
#include "images/ds_bckgrnd.h"
#include "images/welcome.h"
#include "images/start.h"

#include "images/castle.h"
#include "images/shinobu.h"
#include "images/douma.h"
#include "images/kochos.h"

#include "images/win.h"
#include "images/lose.h"

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  INSTRUCTION,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  // Define our slayer and demon in question
  struct slayer charShinobu;
  charShinobu.row = SLAYER_ROW;
  charShinobu.col = SLAYER_COL;
  charShinobu.cd = 3;
  charShinobu.rd = 3; 
  struct demon charDouma;
  charDouma.row = DEMON_ROW;
  charDouma.col = DEMON_COL;

  // Initial states useful for restarting the game
  struct slayer initShinobu = charShinobu;
  struct demon initDouma = charDouma;

  // Score Counter
  int score = 0;
  char scoreS[51];
  sprintf(scoreS, "%d", score);

  // Checks if background needs to be drawn
  int startCheck = 0;

  // Time Counter
  char timeS[51];
  sprintf(timeS, "%d", vBlankCounter / 60);

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    waitForVBlank();
    sprintf(timeS, "%d", vBlankCounter / 60);

    switch (state) {
      case START:
        if (startCheck == 0) {
          drawFullScreenImageDMA(ds_bckgrnd);
          drawImageDMA(0, 85, 70, 25, welcome);
          drawImageDMA((HEIGHT / 2) + 23, (WIDTH / 2) - 25, 50, 25, start);
          drawString(130, 58, "Press START to Start", GREEN);
          drawString(140, 70, "Creator: Kaiwen", YELLOW);
          startCheck = 1;
          score = 0;
          sprintf(scoreS, "%d", score);
        }
     
        // Goes to Instruction Screen
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = INSTRUCTION;
          charShinobu = initShinobu;
          charDouma = initDouma;
          drawFullScreenImageDMA(castle);
        }
        break;

      case INSTRUCTION:
        drawString(5, 5, "Goal: Assist Shinobu in Catching Douma!", YELLOW);
        drawString(15, 5, "Condition: Catch Douma 3 times to Win!", GREEN);
        drawString(25, 5, "Lose: Time took 10 or more seconds!", RED);
        
        drawString(55, 80, "Are You Ready?", GREEN);
        drawString(70, 60, "Click START to Start!", GREEN);
        drawImageDMA((HEIGHT/2), (WIDTH/2) - 40, 85, 60, kochos);

        // Goes to Play Screen
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          drawFullScreenImageDMA(castle);
          vBlankCounter = 0;
        }

        // Reset to Title Screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          startCheck = 0;
        }
        break;

      case PLAY:
        drawImageDMA(charDouma.row, charDouma.col, 25, 25, douma);
        drawImageDMA(charShinobu.row, charShinobu.col, 25, 25, shinobu);
        /*
        drawCenteredString(7, 210, 5, 10, "S:", GREEN);
        drawCenteredString(7, 225, 5, 10, scoreS, GREEN);
        drawCenteredString(21, 210, 5, 10, "T:", GREEN);
        drawCenteredString(21, 225, 5, 10, timeS, GREEN);
        */
        drawCenteredString(7, 210, 5, 10, "S:", GREEN);
        drawCenteredString(21, 210, 5, 10, "T:", GREEN);

        // Update Visual Display for Time
        undrawImageDMA(21, 225, 5, 10, castle);
        drawCenteredString(21, 225, 5, 10, timeS, GREEN);
    
        int oldRow = charShinobu.row;
        int oldCol = charShinobu.col;

        // Moves Shinobu
        if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
          charShinobu.col += charShinobu.cd;
          if (charShinobu.col > WIDTH - 25) {
            charShinobu.col = WIDTH - 25;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {
          charShinobu.col -= charShinobu.cd;
          if (charShinobu.col < 0) {
            charShinobu.col = 0;
          }
        }
        if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
          charShinobu.row -= charShinobu.rd;
          if (charShinobu.row < 0) {
            charShinobu.row = 0;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, BUTTONS)) {
          charShinobu.row += charShinobu.rd;
          if (charShinobu.row > HEIGHT - 25) {
            charShinobu.row = HEIGHT - 25;
          }
        }

        undrawImageDMA(oldRow, oldCol, 25, 25, castle);
        drawImageDMA(charShinobu.row, charShinobu.col, 25, 25, shinobu);

        // Shinobu Collides w/ Douma
        int topLeftCorner = ((charShinobu.row <= charDouma.row + 25) && (charShinobu.row >= charDouma.row) &&
                          (charShinobu.col <= charDouma.col + 25) && (charShinobu.col >= charDouma.col));

        int topRightCorner = ((charShinobu.row <= charDouma.row + 25) && (charShinobu.row >= charDouma.row) &&
                              (charShinobu.col + 25 <= charDouma.col + 25) && (charShinobu.col + 25 >= charDouma.col));

        int botLeftCorner = ((charShinobu.row + 25 <= charDouma.row + 25) && (charShinobu.row + 25 >= charDouma.row) &&
                            (charShinobu.col <= charDouma.col + 25) && (charShinobu.col >= charDouma.col));

        int botRightCorner = ((charShinobu.row + 25 <= charDouma.row + 25) && (charShinobu.row + 25 >= charDouma.row) &&
                            (charShinobu.col + 25 <= charDouma.col + 25) && (charShinobu.col + 25 >= charDouma.col));

        if (topLeftCorner || topRightCorner || botLeftCorner || botRightCorner) {
          score++;
          sprintf(scoreS, "%d", score);
          if (score == 3) {
            state = WIN;
          }
          // Update Visual Display for Score
          undrawImageDMA(7, 225, 5, 10, castle);
          drawCenteredString(7, 225, 5, 10, scoreS, GREEN);

          // Old Douma Disappears and new one respawns!
          // It cannot spawn in same place as Shinobu!
          undrawImageDMA(charDouma.row, charDouma.col, 25, 25, castle);

          int newRow = randint(0, 240 - 25);
          int newCol = randint(0, 160 - 25);

          // Loop until there is no overlap b/w new respawn point of Douma and Shinobu
          while ((charShinobu.row <= newRow + 25) && (charShinobu.row >= newRow) &&
            (charShinobu.col <= newCol + 25) && (charShinobu.col >= newCol)) {
              newRow = randint(0, 240 - 25);
              newCol = randint(0, 160 - 25);
          }
          charDouma.row = newRow;
          charDouma.col = newCol;
        }

        // Reset to Title Screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          startCheck = 0;
        }

        // If time took 10 or or more seconds
        if (vBlankCounter / 60 >= 10) {
          state = LOSE;
        }

        break;
      case WIN:
        drawFullScreenImageDMA(win);
        drawString(140, 10, "Congrats!", GREEN);
        
        // Reset to Title Screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          startCheck = 0;
        }
        break;
      case LOSE:
        drawFullScreenImageDMA(lose);
        drawString(140, 10, "You Lost!", RED);

        // Reset to Title Screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          startCheck = 0;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
